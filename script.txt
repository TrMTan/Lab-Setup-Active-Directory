Import-Module ActiveDirectory -ErrorAction Stop

function Show-Menu {
    Write-Host ""
    Write-Host "Select an option:"
    Write-Host "1) Kerberoasting (add SPN + RC4)"
    Write-Host "2) ASREPRoasting (disable Kerberos pre-auth)"
    Write-Host "3) Shadow Credentials (add user to Key Admins & Enterprise Key Admins)"
    Write-Host "4) DCSync (grant replication rights)"
    Write-Host "5) Golden Ticket (reset krbtgt password - lab)"
    Write-Host "6) ESC1 (create ESC1 via ADCSTemplate or fallback)"
    Write-Host "7) Resource Based Constrained Delegation"
    Write-Host "8) Restore to default"
    Write-Host "0) Exit"
    return (Read-Host "Enter choice")
}

function Show-RestoreMenu {
    Write-Host ""
    Write-Host "Select a vulnerability to restore:"
    Write-Host "1) Kerberoasting"
    Write-Host "2) ASREPRoasting"
    Write-Host "3) Shadow Credentials"
    Write-Host "4) DCSync"
    Write-Host "5) Golden Ticket"
    Write-Host "6) ESC1"
    Write-Host "7) Resource Based Constrained Delegation"
    Write-Host "0) Back to main menu"
    return (Read-Host "Enter choice")
}

# Helper: check if local server has AD CS role and a CA configured
function Check-ADCS-And-CA {
    $result = [PSCustomObject]@{
        ADCSRoleInstalled = $false
        CertSvcService    = $null
        CAConfigured      = $false
    }

    try {
        $feature = Get-WindowsFeature -Name "ADCS-Cert-Authority" -ErrorAction Stop
        if ($feature.Installed) { $result.ADCSRoleInstalled = $true }
    } catch {
        # Ignore errors if Get-WindowsFeature is unavailable
    }

    $svc = Get-Service -Name "CertSvc" -ErrorAction SilentlyContinue
    if ($svc) {
        $result.CertSvcService = $svc.Status
    }

    try {
        if (Test-Path "HKLM:\SYSTEM\CurrentControlSet\Services\CertSvc\Configuration") {
            $result.CAConfigured = $true
        }
    } catch {
        # Ignore registry access errors
    }

    return $result
}

function Ensure-ADCSTemplateModule {
    param([switch]$InstallIfMissing = $true)
    try {
        $mod = Get-Module -ListAvailable -Name ADCSTemplate -ErrorAction SilentlyContinue
        if (-not $mod) {
            if (-not $InstallIfMissing) { return $false }
            Write-Host "ADCSTemplate module not found. Installing from PSGallery..."
            Install-Module -Name ADCSTemplate -Force -Scope CurrentUser -ErrorAction Stop
        }
        Import-Module ADCSTemplate -ErrorAction Stop
        Write-Host "ADCSTemplate loaded." -ForegroundColor Green
        return $true
    } catch {
        Write-Host ("Error loading ADCSTemplate: {0}" -f $_.Exception.Message) -ForegroundColor Yellow
        return $false
    }
}

# Get domain info
$domain = Get-ADDomain
$domainDN = $domain.DistinguishedName
$domainName = $domain.NetBIOSName

# Main menu loop
do {
    $choice = Show-Menu
    $user = $null

    # Prompt for username only for options 1, 2, 3, or 4
    if ($choice -in @('1', '2', '3', '4', '7')) {
        $username = Read-Host "Enter username (e.g., hr.user01) for attack type $choice"
        try {
            $user = Get-ADUser -Identity $username -Properties * -ErrorAction Stop
            Write-Host "User found: $($user.DistinguishedName)"
        } catch {
            Write-Host "Error: User not found. Please try again."
            continue
        }
    }

    switch ($choice) {
        '1' {
            # Kerberoasting: Add SPN and force RC4 encryption
            $spn = "HTTP/$($user.SamAccountName).$($domain.DNSRoot)"
            Set-ADUser -Identity $user -ServicePrincipalNames @{Add=$spn}
            Set-ADUser -Identity $user -Add @{"msDS-SupportedEncryptionTypes"=0x4}  # RC4 only
            Write-Host "Kerberoasting vulnerability set up. SPN added: $spn"
        }
        '2' {
            # ASREPRoasting: Disable pre-auth
            Set-ADAccountControl -Identity $user -DoesNotRequirePreAuth $true
            Write-Host "ASREPRoasting vulnerability set up."
        }
        '3' {
            # Shadow Credentials: Add user to Key Admins and Enterprise Key Admins groups
            Write-Host "Checking AD Certificate Services (ADCS) and Certificate Authority (CA) status on this host..."
            $adcsCheck = Check-ADCS-And-CA

            if ($adcsCheck.ADCSRoleInstalled) {
                Write-Host " - ADCS role appears installed on this server (Get-WindowsFeature detected ADCS-Cert-Authority)."
            } else {
                Write-Host " - ADCS role NOT detected by Get-WindowsFeature (may still be installed if Get-WindowsFeature unavailable)."
            }

            if ($adcsCheck.CertSvcService) {
                Write-Host " - CertSvc service found. Status: $($adcsCheck.CertSvcService)."
            } else {
                Write-Host " - CertSvc service NOT found on this host."
            }

            if ($adcsCheck.CAConfigured) {
                Write-Host " - Registry indicates a configured CA on this host (HKLM:\\...\\CertSvc\\Configuration present)."
            } else {
                Write-Host " - No local CA configuration detected in registry."
            }

            if (-not ($adcsCheck.CertSvcService -or $adcsCheck.ADCSRoleInstalled -or $adcsCheck.CAConfigured)) {
                Write-Host "WARNING: No signs of ADCS/CA on this host. Adding user to Key Admins / Enterprise Key Admins may be unnecessary on this host but will still modify group memberships in AD."
                $proceed = Read-Host "Proceed to add user to groups anyway? (Y/N)"
                if ($proceed -notin @('Y','y')) {
                    Write-Host "Operation cancelled by operator."
                    break
                }
            }

            try {
                $groupsToAdd = @("Key Admins","Enterprise Key Admins")
                foreach ($g in $groupsToAdd) {
                    $group = Get-ADGroup -Identity $g -ErrorAction SilentlyContinue
                    if ($group) {
                        Add-ADGroupMember -Identity $g -Members $user -ErrorAction Stop
                        Write-Host "User added to group: $g"
                    } else {
                        Write-Host "Group not found: $g. Skipping."
                    }
                }
                Write-Host "Shadow Credentials steps completed (group modifications done where groups exist)."
            } catch {
                Write-Host "Error: Failed to add user to Key Admins or Enterprise Key Admins. $_"
            }
        }
        '4' {
            # DCSync: Grant replication rights to the user
            dsacls $domainDN /G "$($user.SamAccountName):CA;Replicating Directory Changes;" > $null 2>&1
            dsacls $domainDN /G "$($user.SamAccountName):CA;Replicating Directory Changes All;" > $null 2>&1
            Write-Host "DCSync rights granted to the user."
        }
        '5' {
            Write-Host "Golden Ticket require hash account KRBTGT, you can setup in option 1,2,3,4 to get hash or just have account Admins"
        }
        '6' {
            Write-Host "Create ESC1: attempting ADCSTemplate workflow..."
            $okModule = Ensure-ADCSTemplateModule -InstallIfMissing

            $sourceDisplayName = Read-Host "Source template display name (default: Code Signing)"
            if ([string]::IsNullOrWhiteSpace($sourceDisplayName)) { $sourceDisplayName = "Code Signing" }

            $templateName = Read-Host "New template display name (default: ESC1)"
            if ([string]::IsNullOrWhiteSpace($templateName)) { $templateName = "ESC1" }

            $root = Get-ADRootDSE
            $configNC = $root.ConfigurationNamingContext
            $templateDN = "CN=$templateName,CN=Certificate Templates,CN=Public Key Services,CN=Services,$configNC"
            $oidClientAuth = "1.3.6.1.5.5.7.3.2"

            if ($okModule) {
                try {
                    Write-Host "Exporting source template to JSON..."
                    $jsonString = Export-ADCSTemplate -DisplayName $sourceDisplayName -ErrorAction Stop
                    if (-not $jsonString) { throw "Export-ADCSTemplate returned no data." }
                    Write-Host "Creating new template via New-ADCSTemplate..."
                    $identityArg = "$($domain.NetBIOSName)\Domain Users"
                    New-ADCSTemplate -DisplayName $templateName -JSON $jsonString -Publish -Identity $identityArg -ErrorAction Stop
                    Write-Host ("Created and published template '{0}' and granted Read/Enroll to '{1}'" -f $templateName, $identityArg) -ForegroundColor Green

                    Set-ADObject -Identity $templateDN -ProtectedFromAccidentalDeletion $false -ErrorAction SilentlyContinue
                    Write-Host "Disabled ProtectedFromAccidentalDeletion for $templateName." -ForegroundColor Cyan

                    Set-ADObject -Identity $templateDN -Replace @{
                        "msPKI-Certificate-Name-Flag"=1
                        "msPKI-Private-Key-Flag"=16842752
                        "msPKI-Template-Minor-Revision"=3
                        "msPKI-Template-Schema-Version"=2
                        "msPKI-Certificate-Application-Policy"=@("1.3.6.1.5.5.7.3.2")
                        "pKIExtendedKeyUsage"=@("1.3.6.1.5.5.7.3.2")
                        "pKICriticalExtensions"=@("2.5.29.7","2.5.29.15")
                        "pKIDefaultCSPs"=@("2,Microsoft Base Cryptographic Provider v1.0","1,Microsoft Enhanced Cryptographic Provider v1.0")
                        "msPKI-Minimal-Key-Size"=2048
                    }
                    Write-Host "Modified template for ESC1 vulnerabilities." -ForegroundColor Green

                    Write-Host "ESC1 creation via ADCSTemplate complete. Verify in certtmpl.msc and certsrv.msc."
                    continue
                } catch {
                    Write-Host ("ADCSTemplate workflow failed: {0}" -f $_.Exception.Message) -ForegroundColor Yellow
                    Write-Host "Falling back to ADSI clone method..."
                }
            } else {
                Write-Host "ADCSTemplate unavailable; using ADSI fallback."
            }
        }
        '7' {
            try {
                $inputName = Read-Host "Enter target computer name (default: DC01)"
                if ([string]::IsNullOrWhiteSpace($inputName)) { $targetComputerName = "DC01" } else { $targetComputerName = $inputName.Trim() }

                # Ensure the AD computer exists
                $computer = Get-ADComputer -Identity $targetComputerName -ErrorAction Stop
                $computerDN = $computer.DistinguishedName
                $adPath = "AD:\$computerDN"

                # Ensure user object is available in $user (set earlier when choice in @('1','2','3','4','7'))
                if (-not $user) {
                    Write-Host "User variable not set. Please re-enter username." -ForegroundColor Yellow
                    break
                }

                # Confirm user exists (if $user already pulled earlier this will pass)
                $targetUser = Get-ADUser -Identity $user.SamAccountName -ErrorAction Stop

                # Build identity in DOMAIN\samaccount format
                $identity = New-Object System.Security.Principal.NTAccount("$domainName\$($targetUser.SamAccountName)")

                # Get current ACL on the computer object
                $acl = Get-Acl -Path $adPath

                # Create Active Directory access rule for GenericAll (Full Control)
                $rights = [System.DirectoryServices.ActiveDirectoryRights]::GenericAll
                $ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule(
                    $identity,
                    $rights,
                    [System.Security.AccessControl.AccessControlType]::Allow
                )
                # Add rule and apply
                $acl.AddAccessRule($ace)
                Set-Acl -Path $adPath -AclObject $acl
                Write-Host "Success: Granted Full Control (GenericAll) on computer object $targetComputerName to $($targetUser.SamAccountName)." -ForegroundColor Green
            } catch {
                Write-Host "Error granting Full Control on {$targetComputerName}: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        '8' {
            # Restore submenu
            do {
                $restoreChoice = Show-RestoreMenu
                $user = $null

                # Prompt for username only for options 1, 2, 3, or 4 in restore menu
                if ($restoreChoice -in @('1', '2', '3', '4')) {
                    $username = Read-Host "Enter username (e.g., hr.user01) to restore settings for"
                    try {
                        $user = Get-ADUser -Identity $username -Properties * -ErrorAction Stop
                        Write-Host "User found: $($user.DistinguishedName)"
                    } catch {
                        Write-Host "Error: User not found. Please try again."
                        continue
                    }
                }

                switch ($restoreChoice) {
                    '1' {
                        # Kerberoasting:4830 Remove SPNs and reset encryption types
                        try {
                            Set-ADUser -Identity $user -ServicePrincipalNames $null -Clear "msDS-SupportedEncryptionTypes"
                            Write-Host "Kerberoasting removed successfully"
                        } catch {
                            Write-Host "Kerberoasting remove errors: $_"
                        }
                    }
                    '2' {
                        # ASREPRoasting: Enable pre-auth
                        try {
                            Set-ADAccountControl -Identity $user -DoesNotRequirePreAuth $false
                            Write-Host "ASREPRoasting removed successfully"
                        } catch {
                            Write-Host "ASREPRoasting remove errors: $_"
                        }
                    }
                    '3' {
                        # Shadow Credentials: Remove user from Key Admins and Enterprise Key Admins groups
                        try {
                            Remove-ADGroupMember -Identity "Key Admins" -Members $user -Confirm:$false -ErrorAction SilentlyContinue
                            Remove-ADGroupMember -Identity "Enterprise Key Admins" -Members $user -Confirm:$false -ErrorAction SilentlyContinue
                            Write-Host "Shadow Credentials restored: User removed from Key Admins and Enterprise Key Admins groups (if present)."
                        } catch {
                            Write-Host "Shadow Credentials restore skipped or partially failed: $_"
                        }
                    }
                    '4' {
                        # DCSync: Remove specific rights
                        try {
                            dsacls $domainDN /R "$($user.SamAccountName)" > $null 2>&1
                            Write-Host "DCSync removed successfully"
                        } catch {
                            Write-Host "DCSync remove errors: $_"
                        }
                    }
                    '5' {
                        # Golden Ticket: Not user-specific, suggest manual
                        Write-Host "Golden Ticket is domain-wide; manually reset krbtgt password twice if needed."
                    }
                    '6' {
                        # Remove ESC1 template
                        Write-Host "Remove ESC1: attempting ADCSTemplate removal..."
                        $okModule = Ensure-ADCSTemplateModule -InstallIfMissing:$false
                        $templateName = Read-Host "Template display name to remove (default ESC1)"
                        if ([string]::IsNullOrWhiteSpace($templateName)) { $templateName = "ESC1" }

                        if ($okModule) {
                            try {
                                if (Get-Command -Name Remove-ADCSTemplate -ErrorAction SilentlyContinue) {
                                    Remove-ADCSTemplate -DisplayName $templateName -Confirm:$false -ErrorAction Stop
                                    Write-Host ("Removed template '{0}' via ADCSTemplate module." -f $templateName) -ForegroundColor Green
                                } else {
                                    throw "Remove-ADCSTemplate command not present in module."
                                }
                            } catch {
                                Write-Host ("ADCSTemplate removal failed: {0}" -f $_.Exception.Message) -ForegroundColor Yellow
                                Write-Host "Falling back to ADSI removal..."
                            }
                        } else {
                            Write-Host "ADCSTemplate not available; using ADSI fallback."
                        }
                    }
                    '7' {
                        try {
                            $inputName = Read-Host "Enter target computer name to restore (default: DC01)"
                            if ([string]::IsNullOrWhiteSpace($inputName)) { $targetComputerName = "DC01" } else { $targetComputerName = $inputName.Trim() }

                            # Verify computer exists in AD
                            $computer = Get-ADComputer -Identity $targetComputerName -ErrorAction Stop
                            $computerDN = $computer.DistinguishedName
                            $adPath = "AD:\$computerDN"

                            # Prompt for the user to remove from Security (samAccountName)
                            $username = Read-Host "Enter username to remove from Security:"
                            $targetUser = Get-ADUser -Identity $username -ErrorAction Stop

                            # Build NTAccount identity (DOMAIN\samAccountName)
                            $identity = New-Object System.Security.Principal.NTAccount("$domainName\$($targetUser.SamAccountName)")

                            # Get existing ACL (ActiveDirectorySecurity)
                            $acl = Get-Acl -Path $adPath

                            # Get all rules (explicit + inherited) as ActiveDirectoryAccessRule objects
                            $allRules = $acl.GetAccessRules($true, $true, [System.Security.Principal.NTAccount])

                            # Create a new ActiveDirectorySecurity and copy back only rules NOT belonging to the target identity
                            $newAcl = New-Object System.DirectoryServices.ActiveDirectorySecurity

                            foreach ($r in $allRules) {
                                if ($r.IdentityReference -ne $identity) {
                                    # Add the rule back to the new ACL
                                    $newAcl.AddAccessRule($r) | Out-Null
                                }
                            }

                            # Immediately break inheritance on new ACL (do not keep inherited ACEs) as requested
                            $newAcl.SetAccessRuleProtection($true, $false)

                            # Apply the new ACL to the AD object
                            Set-Acl -Path $adPath -AclObject $newAcl

                            # Extra cleanup: try dsacls to remove any leftover explicit rights
                            try {
                                dsacls $computerDN /R "$($targetUser.SamAccountName)" > $null 2>&1
                                dsacls $computerDN /R "$($domainName)\$($targetUser.SamAccountName)" > $null 2>&1
                            } catch {
                                # non-fatal
                            }

                            # Verify final state
                            $aclFinal = Get-Acl -Path $adPath
                            $remaining = $aclFinal.GetAccessRules($true, $true, [System.Security.Principal.NTAccount]) | Where-Object { $_.IdentityReference -eq $identity }

                            if ($remaining.Count -eq 0) {
                                Write-Host "Success: removed all permissions and removed user $($targetUser.SamAccountName) from the Security of $targetComputerName." -ForegroundColor Green
                            } else {
                                Write-Host "Warning: $($remaining.Count) ACE(s) for $($targetUser.SamAccountName) remain. Please review manually." -ForegroundColor Yellow
                                foreach ($x in $remaining) { Write-Host $x }
                            }
                        } catch {
                            Write-Host "Error removing user from Security: $($_.Exception.Message)" -ForegroundColor Red
                        }
                    }
                    '0' {
                        Write-Host "Returning to main menu..."
                        break
                    }
                    default {
                        Write-Host "Invalid choice."
                    }
                }
            } while ($restoreChoice -ne '0')
        }
        '0' {
            Write-Host "Exiting..."
            break
        }
        default {
            Write-Host "Invalid choice."
        }
    }

} while ($choice -ne '0')

Write-Host "Done."